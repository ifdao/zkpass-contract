# zkpass whitepaper

## KYC in a broader sense (Know Your Customer)

  Web1 is the readable Internet. We can get news and information from the Internet, but we can only get information unilaterally and cannot participate in interaction. We can leave comments to express our opinions, chat with each other in private messages, and post topics. However, the data created by users on these networks does not belong to them.

  Web3 is not only readable and writable, but it can also truly have the user's control over the data. For example, control of the web accounts we use, control of the data generated by our online behavior, control of the billing transactions we perform over the web, etc. Note that even though our future technology paradigm will evolve from Web2 to Web3, we only get control of the data, not the data itself. Authentication is a classic example of this.

  We define authentication to include strong authentication (e.g. KYC requires deterministic identity) and weak authentication (e.g. OAuth authorization for Github mailboxes).

  Identity solves the problem of "who I am". Authentication is the problem of "proving that someone is someone". In the physical world, we are identified by "ID", "passport", "driver's license", "bank card The media such as "ID card", "passport", "driver's license", "bank card", etc. are authenticated directly by the authority. In the digital world, our identity is indirectly authenticated by "social account", "cell phone number", "deposit account" and other data via trusted media to the authority. At this stage, both the physical and digital worlds are inseparable from the source of identity authentication: the authority, because they create your identity information and store it in the trusted medium of Web2. So the Web3 privacy identity protocol we are about to build will still inevitably need to reference Web2 data sources .There are many examples of Web3 referencing Web2 data sources to authenticate identities, such as the address identity authentication in the Web2 social platform for the project's airdrop marketing campaign to prevent witch attacks.

## Existing KYC Solutions

  In the traditional Web2 domain, some middleware providers offer KYC solutions for their customers, including but not limited to authentication management, identity management, permission management, and so on. Some of these service providers have transplanted their mature KYC solutions to the Web3 space, and some have introduced the concept of so-called "decentralized KYC". Looking at these solutions, whether centralized or so-called "decentralized", the implementation model is as follows.
![](/Users/koala/Work/ifdao/zkpass-contract/docs/images/1_sequence.jpg)

* Participants
  
  * Verifier (Verifier): i.e. a business user or project party that uses KYC services.
  
  * Prover (Proven): i.e. ordinary user.
  
  * KYC Service Provider (KYC Service Provider).
  
  * Issuer: e.g. IDD (International Driver Document), financial institutions such as banks, online social media platforms such as twitter, etc.

* Preparation.
  
  * Open verification interface for identity issuers.
  * KYC service providers to interface with as many identity issuers as possible and obtain interfaces for identity verification.
  * The verifier needs to go to the KYC service provider to register for the service and or obtain an API Key.

* complete KYC process.
  
  * The certifier obtains the KYC service access token from the verifier.
  
  * The token is used by the certifier to send personal information to the KYC service provider.
  
  * The KYC service provider gets the user's personal information, forwards it to the corresponding identity issuer for verification, and obtains the results.
  
  * KYC service providers return KYC results to the verifier through redirection.
  
  * subsequent business logic processing by the validator based on KYC results.
    
    From the above KYC context, it is clear that to ensure the proper functioning of the entire system, the KYC service provider must be assumed to be a trusted and centralized institution. Not only does this mode of operation not go centralized and cannot guarantee that users' private data will not be leaked, such as the KYC data leak of an exchange that was hacked for ransom in 2019; moreover, there is a great risk of mischief for KYC service providers, and private data will most likely be collected and maliciously used by KYC service providers.
    
    In addition to the major flaws mentioned above, this KYC model suffers from the following problems.
  
  * The user's private identity data is repeatedly collected by multiple verifiers, and the user has no right to dispose of the collected identity information.
  
  * KYC service providers can block KYC requests from specific certifiers, making it impossible for users to participate in the subsequent business logic and project ecology of the certifier.
  
  * The entire system is extremely dependent on the authentication interface opened by the identity issuer for the KYC service provider, and it is difficult for the KYC service provider to force the identity issuer to add or modify the interface for its business, which results in most KYC requirements not being met.
  
  * KYC service providers are unable to provide programmable KYC services, resulting in a significant amount of additional user privacy information being leaked to the verifier. For example, the verifier requires the user to prove that the bank deposit is greater than $1 million, but the KYC service provider actually returns the deposit balance to the verifier user.
  
  ## Improved KYC model
  
    To overcome the above-mentioned shortcomings, a natural idea is to adopt Web3 to completely decentralize and remove service providers from the KYC chain; and introduce ZKP (Zero-Knowledge Proof) to protect private data from being leaked.
  
    We define a new KYC model.
  
  * The certifier communicates directly with the identity issuer to obtain authentication.
  * Proof of KYC verification passed by the certifier is generated and sent to the verifier.
  * The validator verifies the legitimacy of the proof and performs subsequent business logic processing based on the validation results.
    A KYC system using this model not only allows the certifier to have absolute control over his or her private data, but through ZKP, it also makes it possible for the private data to be leaked without any risk of being leaked to third parties; since the user communicates directly with the identity issuer, the identity issuer can return nearly all of the user's information as long as it is verified through token (the user holds the username password), and the entire system's KYC capability is greatly enhanced; users can return proofs that only satisfy the constraints of the KYC requirements of the verifier, further ensuring that private data is not leaked to the verifier.
    Unfortunately, however, this model is too idealistic, while introducing new problems.
  * Compatibility: The system requires that the data of each traditional Web2 identity issuer must be introduced in a decentralized Web3 network and that their interfaces are compatible. In the current Web3 space, there does not yet exist a solution that does not rely on third parties.
  * Anti-cheating and security: The lack of effective oversight of the communication process between the certifier and the identity issuer and the process of generating proofs allows the certifier to forge proofs to deceive the verifier. For example, Alice wants to prove to Bob that her twitter account has more than 3000 followers: Alice could send a request to a fake "titter", return 300000 followers and construct a proof for Bob to verify. Alice can even forge a local followers of 300000 based on the format of the data returned by twitter without any network communication, and construct a proof for Bob to verify; Bob will still be able to verify the data without being able to confirm the source.
    To solve all the above problems, we propose zkPass.
    
    ## zkPass
    
    zkPass is a decentralized KYC solution based on MPC (Multi-Party Computation) and ZKP, which aims to overcome various flaws in the current KYC system, eliminate the pain points related to identity verification, and protect user privacy while expanding KYC capabilities.
  
  zkPass allows customers to anonymously prove their statements of identity to third parties (other project parties/Verifiers) through the Credential held by the Web2 identity issuer, converting Web2 customer identity credentials into anonymous credentials without the need for a centralized server (traditional KYC platforms) or trusted hardware (TEE, etc.). The zkPass protocol is the perfect alternative to traditional KYC service providers, providing businesses and users with the next dimension of KYC solutions in a completely decentralized format.
  
  For business users or project parties, they can quickly, easily and conveniently integrate their legacy projects with zkPass and gain far greater KYC capabilities by conducting in-chain queries through the API gateway while choosing not to collect user data. zkPass offers a combination of KYC templates, allowing business users to choose the solution size that is applicable to each business and jurisdiction; while business Users can expand existing templates with zkPass Kit based on their individual KYC needs. Whether it's identity verification, address verification, social network verification, capital verification reports, face recognition authentication, and more, zkPass can provide a full range of verification solutions.
  
  For the average user, zkPass is a user-centric KYC solution that completely eliminates user privacy breaches from the protocol layer while easing the pain of new account opening and repeated KYC redos. Once a user completes KYC verification, they can immediately join a related business or service within the zkPass ecosystem. With all information and data remaining under the control of the owner, coupled with the reusable nature of KYC and authentication, zkPass allows for a faster, cheaper and often more efficient way of working, further enhancing the user experience.
  
  ### zkPass Protocol
  
  ##### Symbols and definitions
  
  * P stands for prover
  
  * V is for verifier
  
  * S for TLS server
  
  * Q for P-initiated queries
  
  * R is for S Reply data
  
  * enc_key represents the key of the encrypted data in TLS
  
  * mac_key represents the MAC key in TLS 
  
  * t stands for summary (Digest)
    
    ##### Related Technologies
  
  * TLS: Secure Transport Layer Protocol, a protocol used to provide confidentiality and data integrity between two communicating applications. tls is the cornerstone of communication in the web world.
  
  * MPC: Secure Multiparty Computation, which allows multiple participants to jointly participate in the computation without revealing their privacy, here mainly uses obfuscated circuits and optimized fast multiparty computation ECDSA algorithms.
  
  * ZKP: Zero Knowledge Proof, which refers to the ability of a prover to convince a verifier that an assertion is correct without providing any useful information to the verifier, and the specific implementation will use the PLONK algorithm.
    
    ##### Three stages:
  
  * Multi-party handshake.
    
    * P gets (tid, uri, assert) from V. uri is the api of the query and assert is the result assertion.
    * {P, V} performs a three-way handshake with the TLS server, P authenticates the CA first, P sends $(r_c,r_s,pk_s,ca,digest)$ to V.
    * V verifies CA and digest, V samples$F_v \mapsto S_v$ , Yv = Sv * G. Send Yv to P.
    * P samples$F_p \mapsto S_p$ , Yp = Sp * G. Send  $Y_{vp}=Y_v+Y_p$ to S.
    * {P,V} calculate the session key and master secret by mpc.
      * Public Input: $nounce,r_c,r_s$
      * Private input: $z_p \isin F_p from P;z_v \isin F_p \ from \ V$
      * $z :=z_p+z_v$
      * $m :=PRF(z,"master secret",r_s || r_c)$
      * $enc\_key,mac\_key := PRF(m,"key partation",r_s || r_c)$
      * samples $F_p \mapsto r_k,r_m$ , send $(enc\_key,k_p,r_m)$ to P and send $(r_k \oplus mac\_key,r_m \oplus m)$ to V.
  
  * Data query.
    
    * P assembles Q by filling the password (token) into uri, P computes the digest t by MPC-HMAC together with V, and then P sends (tid, Q'= Enc($enc\_key,Q||t$ )) to S.
  
  * Zero-knowledge proof.
    
    * P received a reply R' from the server
    
    * P sends $(tid,Q',R',mac\_key)$ to V.
    
    * V sends $(tid,mac\_key\_v)$ to P.
    
    * P calculate $mac\_key = mac\_key\_p+mac\_key\_v$ , P decrypts R||t = Dec($enc\_key,R'$), and verifies t.
    
    * Generate proof
      
      ```plain
      P set
        b= assert(R)
        x = (Q', R', mac_key, b) ;
        w = (enc_key, token, Q, R)
      
      }
      Constraints {
        Dec(enc_key, R') = R || t ;
        Verify(mac_key, t , R) = 1 ;
        b =assert(R)
        Q = uri(token);
      }
      ```
    
    * V verification proof.
      With ZKP, the user's privacy is guaranteed while providing proof for third parties; with MPC, the prover and verifier jointly hold the mac_key, ensuring that the prover cannot cheat; and all of this is built on the standard TLS protocol, without any changes to the server.

## Implementation of zkPass protocol
  The overall system architecture of zkPass is shown in the following figure.
![](/Users/koala/Work/ifdao/zkpass-contract/docs/images/2_architecture.jpg)

The overall system includes the following components.

 * zkPass Kit: The client of the zkPass protocol, which is an implementation of the provers (Prover) in the zkPass protocol. Business users select or customize a suitable KYC template according to their needs, configure the template into zkPass Kit in the form of parameters, and initiate KYC requests to the smart contract on the chain. In order to avoid repeated verification, zkPass Kit first goes to the ZKPass Backend to find out if this KYC authentication already exists in the zkPass ecology; if not, it is responsible for conducting MPC with the Nodes node selected for this KYC task, generating mac_key, and performing HMAC calculations on the messages in subsequent TLS communications The zkPass Kit can be loaded in the user's browser as a browser plug-in or integrated into the front-end service of an enterprise user as an SDK.

 * TheGraph: TheGraph is a protocol for querying and indexing blockchain network data. By generating subgraphs, the data on the chain is indexed so that data that is difficult to query directly can be queried. It makes on-chain data queries fast, reliable and secure. zkPass uses TheGraph protocol to index KYC requests and results on the chain for zkPass Backend queries. Note that TheGraph can only index on-chain data, i.e. KYC requests initiated by an address and KYC verification results corresponding to that address, and cannot access any private user data; users can even hide KYC verification results by configuring zkPass Kit's parameters to further protect their privacy.

 * zkPass Backend: By querying the KYC requests and results on the chain indexed by TheGraph and aggregating the open data of users corresponding to that address, it generates authentication cards for users, preventing duplicate KYC authentication, accelerating the KYC efficiency of the zkPass system, and improving the user experience.

 * Blockchain Smart Contract: An on-chain smart contract that consists of three components.
  
  * Template contract: The template for KYC verification contains assert, query and their corresponding parameters. Business users can configure the template with parameters such as age over 18 (age is a parameter) and twitter followers over 100 (followers is a parameter). The zkPass Kit allows business users to select the appropriate KYC template from the contract and use it. Business users and developers can also create new templates based on their needs, which will be added to the template contract after receiving confirmation from the community.
  * Task Manage contract: Receives KYC requests from zkPass Kit, generates tid (task id), randomly selects k nodes (k>=1) from the registered nodes (or as specified by the enterprise user's configuration), and returns node information to zkPass Kit for subsequent MPC.
  * ZK Verification contract: After zkPass Kit completes commit, it accepts ZKP submitted by zkPass Kit, verifies the validity of ZKP, and returns the verification result.

* Node Cluster: The consensus node network is an implementation of the Verifier in the zkPass protocol. When a user invokes the on-chain smart contract interface to initiate a KYC request, the nodes in this network listen to the Task Manage contract to determine whether they are selected to participate in subsequent KYC tasks; when selected, they wait for the request initiated by zkPass Kit, participate in the subsequent multi-party handshake, query data, and disclose the mac_key held after ZKP submission. it should be noted that When the enterprise user turns on random mode to select nodes, in order to prevent individual nodes from being evil, multiple nodes are randomly selected in the Task Manage contract to participate in the MPC of the zkPass protocol. It is easy to see from the zkPass protocol that as long as there is an honest node participating in this KYC task, the certainty of this KYC task can be guaranteed; the enterprise user can also run their own KYC node and specify the choice of that node in the KYC task, making subsequent MPCs degenerate to 2PC.

* Web2 Issuers: The identity issuer's server, which satisfies the TLS protocol, is sufficient for the user to obtain identity information from the server. A complete KYC authentication process can be described as follows: 
  
  * the business user obtains (creates) a template from the chain, configures parameters related to the KYC authentication template, and integrates it into its front-end service; 
  * the user accesses the business user's front-end service, brings up the zkPass Kit, and initiates a KYC request to the chain contract based on the template specified in that front-end service; 
  * the chain contract receives the KYC request, generates a tid The on-chain contract receives the KYC request, generates the tid, randomizes (or specifies) the nodes participating in the MPC, and returns the tid and node information to zkPass Kit; 
  * zkPass Kit, the selected nodes, and the identity issuer server start the multi-party handshake and data query according to the zkPass protocol, and generate the ZKP; 
  * zkPass Kit sends the generated zero-knowledge proof The ZKPass Kit sends the generated zero-knowledge proofs to the on-chain verification contract for verification; 
  * the mac_keys of the selected nodes in this task are used as part of the public input for this ZKP verification;
  * the on-chain verification contract performs the verification process based on all the submitted public input, wisdom and proof, and returns the verification result of this KYC. The on-chain validation contract performs the validation process based on all the submitted public inputs, witeness and proof, and returns the KYC validation result.

* Implementation on Mina Protocol: zkApp uses Typescript to implement zero-knowledge proof, which is more friendly to developers; Mina's zero-knowledge is based on PLONK algorithm with constant proof size, which is suitable for authentication application scenarios. Since the verification message digest uses the CBC-HMAC algorithm, here we need to implement our own CBC-HMAC algorithm circuit. p inherit Circuit to create the circuit, private input (Q', R', mac_key, b), public input (enc_key, token, Q, R), and also create the verificationKey to send to the contract. v Inherit SmartContract to create verification contract, receive verificationKey from P and proof verify if it passes.
  
  ## Summary and Outlook
  
  As the most controversial topic since the birth of the Internet, identity and data are not only a true mapping of people's footprints on the Internet and the real world, but also bring more complex challenges such as personal privacy protection. As data privacy protection becomes an increasingly important area for users, society and regulation, data security and data sovereignty governance have become difficult challenges for enterprises to overcome on the road to digitalization. zkPass uses blockchain, ZKP, MPC and other technologies to help desensitize identities, avoid sensitive data theft, return private data to owners, and create a convenient and jointly controllable digital identity management system. management system. zkPass can work without any programmatic support from traditional identity issuers, minimizing reliance on the availability of identity issuers and making anonymous credentials still compatible with the use of identity authorization. Compared to any previous KYC system, zkPass truly builds a complete decentralized, privacy-preserving KYC solution.
  
  Based on zkPass, we can establish a one-person-one-account system in a privacy-protected and non-authoritative way, and can build a reputation system without relying on authoritative credit scoring, and can even extend the concept of KYC further forward to create new business models such as KYB (know your business) and KYD (know your device). As an important infrastructure for Web3.0, zkPass can better promote the digital economy, build a socially oriented, secure and convenient distributed digital identity system, solve the security, privacy, interoperability and ownership problems of existing online digital identities, create new blockchain landing application scenarios, and further promote the flourishing development of Web3.